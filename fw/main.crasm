CPU 6502
OUTPUT HEX

; Vectors
NMI_VECT equ 0xFFFA
IRQ_VECT equ 0xFFFC
RST_VECT equ 0xFFFE

; Memory
ROM_BEGIN equ 0xF800
ROM_END   equ 0xFFFF
RAM_BEGIN equ 0x0000
RAM_END   equ 0x0800

; I/O
EXT1_BASE equ 0x2000
EXT2_BASE equ 0x4000
EXT3_BASE equ 0x6000
SCRN_BASE equ 0x8000
KEYB_BASE equ 0xA000
NMI_CLR   equ 0xC000

; Key codes
KEY_INC  equ 16
KEY_DEC  equ 17
KEY_SEL  equ 18
KEY_GO   equ 19
KEY_F1   equ 20
KEY_F2   equ 21
KEY_F3   equ 22
KEY_F4   equ 23
KEY_NONE equ 24

; Screen
SCRN_DOT   equ 0x10
SCRN_BLANK equ 0x20

; Time base
NMI_HZ       equ 1024
KEYB_COOLDWN equ 50


DUMMY

; Zero page variables
* = RAM_BEGIN

; Accessed by NMI
init_done       ds 1 ; 0 - init done, others - NMI shouldn't do it's tasks

screen          ds 8
scrnptr         ds 1

keycode         ds 1

jiffies         ds 2 ; Only for NMI use - non-atomic access
time_s          ds 1

nmi_temp        ds 1

; Not accessed by NMI

temp            ds 1
get_key_temp    ds 1
sleep_temp0     ds 1
sleep_temp1     ds 1

address         ds 2
mode_sel        ds 1

irq_ptr         ds 2
irq_valid       ds 1


CODE

* = ROM_BEGIN

; BIOS function table
dw reset          ; void reset(void)
dw get_screen_ptr ; screen_ptr (stack) get_screen_ptr(void)
dw decode_7seg    ; 7seg decode_7seg(character (A))
dw putch          ; void putch(character (A), position (X))
dw putbyte        ; void putch(byte (A), position (X))
dw dot_enable     ; void dot_enable(position (X))
dw dot_disable    ; void dot_disable(position (X))
dw get_key        ; key_code (A) get_key(void)
dw irq_register   ; void irq_register(irq_addr (stack))
dw get_jiffies    ; jffies (A) get_jiffies(void)
dw get_seconds    ; seconds (A) get_seconds(void)
dw msleep         ; void msleep(time (A))
dw sleep          ; void sleep(time (A))


; Const storage

lut_7seg        db 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 ; Dot disabled
                db 0xBF, 0x86, 0xDB, 0xCF, 0xE6, 0xED, 0xFD, 0x87, 0xFF, 0xEF, 0xF7, 0xFC, 0xB9, 0xDE, 0xF9, 0xF1 ; Dot enabled
                db 0x00                                                                                           ; Digit disabled

lut_ptr2bit     db 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80


; "Business" code, handling user inputs, monitor functionality

; Function decode_7seg
; Decodes 4-bit nibble to 7-segment.
; Input: A - character. Output: A - decoded 7-segment.
; Destroys: A, X.
decode_7seg     AND #0x0F
                TAX
                LDA lut_7seg, X
                RTS


; Function get_screen_ptr
; Returns a pointer to screen frame buffer
; Input: none. Output: stack - screen_ptr high, stack + 1 - screen_ptr low.
; Destroys: A.
get_screen_ptr  LDA #screen & 0xFF
                PHA
                LDA #screen >> 8
                PHA
                RTS


; Function msleep
; Sleep for 0-255 ms
; Input: A - sleep time in ~1ms. Output: none.
; Destroys: A, sleep_temp0, sleep_temp1.
msleep          STA sleep_temp0
                LDA jiffies
                STA sleep_temp1
msleep_loop     LDA jiffies
                CLC
                SBC sleep_temp1
                CMP sleep_temp0
                BMI msleep_loop
                RTS


; Function sleep
; Sleep for 0-255 s
; Input: A - sleep time in 1s. Output: none.
; Destroys: A, sleep_temp0, sleep_temp1.
sleep           STA sleep_temp0
                LDA time_s
                STA sleep_temp1
sleep_loop      LDA time_s
                CLC
                SBC sleep_temp1
                CMP sleep_temp0
                BMI sleep_loop
                RTS


; Function get_jiffies
; Fetches 8-bit ~1ms period timer
; Input: none. Output: A - jiffies.
; Destroys: A.
get_jiffies     LDA jiffies
                RTS


; Function get_seconds
; Fetches 8-bit 1s period timer
; Input: none. Output: A - seconds.
; Destroys: A.
get_seconds     LDA time_s
                RTS


; Function irq_register
; Registers user IRQ handler
; Input: stack - function address high, stack + 1 - function address low. Output: none.
; Destroys: A.
irq_register    LDA #0
                STA irq_valid
                PLA
                STA irq_ptr + 1
                PLA
                STA irq_ptr
                RTS


; Function putch
; Updates one char on the screen.
; Input: A - char, X - position. Output: screen.
; Destroys: none.
putch           STA screen, X
                RTS


; Function putbyte
; Updates byte char on the screen.
; Input: A - byte, X - position. Output: screen.
; Destroys: X - incremented to the next screen location.
putbyte         PHA
                LSR A
                LSR A
                LSR A
                LSR A
                JSR putch
                INX
                PLA
                AND #0x0F
                JSR putch
                INX
                RTS


; Function dot_enable
; Turns a dot on on position X on the screen.
; Input: X - position. Output: screen.
; Destroys: A.
dot_enable      LDA #0x10
                CLC
                ORA screen, X
                STA screen, X
                RTS


; Function dot_disable
; Turns a dot off on position X on the screen.
; Input: X - position. Output: screen.
; Destroys: A.
dot_disable     LDA #0x2F
                CLC
                AND screen, X
                STA screen, X
                RTS


; Function draw_screen
; Updates screen - current address and memory value.
; Input: address, mode_sel. Output: screen.
; Destroys: A, X, Y.
draw_screen     LDX #0
                LDY #0

                LDA address + 1
                JSR putbyte

                LDA address
                JSR putbyte

                LDA #SCRN_BLANK
                JSR putch
                INX
                JSR putch
                INX

                LDA (address), Y
                JSR putbyte

                LDA mode_sel
                LDX #7
                CMP #0
                BEQ draw_screen_e
                LDX #3

draw_screen_e   JSR dot_enable
                RTS


; Function get_key
; Blocks until a key is pressed
; Input: none. Output: A - key code.
; Destroys: A, keyb_start
get_key         LDA keycode
                CMP KEY_NONE
                BNE get_key             ; Wait for none key pressed
                LDA jiffies
                STA get_key_temp        ; Begin cooldown period
get_key_cooldwn LDA keycode
                CMP KEY_NONE
                BNE get_key             ; Check if still not pressed
                LDA jiffies
                CLC
                SBC get_key_temp
                CMP #KEYB_COOLDWN
                BPL get_key_cooldwn     ; Wait for KEYB_COOLDWN jiffies
get_key_press   LDA keycode
                CMP KEY_NONE
                BEQ get_key_press       ; Wait for key press
                RTS


; Function reset
; Entry point.
reset           LDA #0xff
                STA init_done
                CLI
                CLD

                ; Setup stack
                LDX #0xff
                TXS

                ; Init variables
                LDA #KEY_NONE
                STA keycode

                ; Clear screen
                LDA #SCRN_BLANK
                LDX #7
reset0          STA screen, X
                DEX
                BPL reset0

                ; Keycode
                LDA #KEY_NONE
                STA keycode

                ; Jiffies, timers
                LDA #0
                STA jiffies
                STA jiffies + 1
                STA time_s

                ; IRQ handling
                STA irq_ptr
                STA irq_ptr + 1
                STA irq_valid

                ; Address
                STA address
                LDA #0x20
                STA address + 1

                ; Init done!
                LDA #0
                STA init_done
                SEI

main_loop       JSR draw_screen

                JSR get_key

                CMP #16
                BPL main_inc

                ; 0-F key pressed - edit one digit
                PHA
                LDA mode_sel
                CMP #0
                BEQ main_edit_b

                ; Edit address
                CLC
                ROL address + 1
                ROL address
                ROL address + 1
                ROL address
                ROL address + 1
                ROL address
                ROL address + 1
                ROL address
                LDA 0xF0
                AND address
                STA address
                PLA
                ORA address
                STA address

                JMP main_loop

main_edit_b     LDY #0
                LDA (address), Y
                ASL A
                ASL A
                ASL A
                ASL A
                STA temp
                PLA
                ORA temp
                STA (address), Y
                JMP main_loop

main_inc        CMP #KEY_INC
                BNE main_dec

                ; INC key pressed - increment address
                INC address
                BNE main_loop
                INC address + 1
                JMP main_loop

main_dec        CMP #KEY_DEC
                BNE main_sel

                ; DEC key pressed - decrement address
                LDA address
                CLC
                SBC #1
                STA address
                BCC main_loop
                DEC address + 1
                JMP main_loop

main_sel        CMP #KEY_SEL
                BNE main_go

                ; SEL key pressed - change edit mode
                LDA #1
                EOR mode_sel
                JMP main_loop

main_go         CMP #KEY_GO
                BNE main_loop ; Ignore function keys

                ; GO key pressed - execute user program
                ; Prepare return address
                LDA #reset & 0xFF
                PHA
                LDA #reset >> 8
                PHA

                JMP (address)


; System functions

; Function irq
; Handles IRQ - TODO.
; Input: None. Output: None.
; Destroys: None
irq             PHA

                ; Exit if IRQ is not enabled by a user SW
                LDA irq_valid
                BEQ irq_ret

                TYA
                PHA
                TXA
                PHA

                ; There's no indirect JSR we need - do it hard way
                ; Prepare return address on stack to allow RTS
                LDA #irq_end & 0xFF
                PHA
                LDA #irq_end >> 8
                PHA

                ; Jump to address pointed by irq_ptr
                JMP (irq_ptr)

irq_end         PLA
                TAX
                PLA
                TAY
                PLA
irq_ret         PHA
                RTI


; Function nmi
; Handles NMI - jiffies, keyboard, screen.
; Input: None. Output: None.
; Destroys: None
nmi             PHA
                TYA
                PHA
                TXA
                PHA

                ; Early exit if init is not complete
                ; We cannot disable NMI, so this is needed
                LDA init_done
                CMP 0
                BNE nmi_end

                ; Increment jiffies
                JSR handle_timer

                ; Handle UI
                JSR refresh_screen
                JSR scan_keyboard

                ; Clear NMI to allow a next one to occur
                ; Dummy write to preset 74HC74 flip-flop
                STA NMI_CLR

nmi_end         PLA
                TAX
                PLA
                TAY
                PLA
                RTI


; Function handle_timer
; Time keeping. Assumption - called every NMI
; Input: jiffies var. Output: jiffies, time_s vars.
; Destroys: A, X.
handle_timer    INC jiffies
                BNE handle_timer_1
                LDX jiffies + 1
                INX
                TXA
                CMP #NMI_HZ / 256
                BMI handle_timer_0
                INC time_s
                LDA #0
handle_timer_0  STA jiffies + 1
handle_timer_1  RTS


; Function refresh_screen
; Displays next digit on multiplexed 7 segment display
; Input: screen, scrnptr vars. Output: scrnptr.
; Destroys: A, X, Y.
refresh_screen  LDX scrnptr
                INX                     ; Increment current digit
                TXA
                CMP #8
                BMI refresh_screen0     ; Screen wrap-around?
                LDA #0
refresh_screen0 TAX
                STA scrnptr
                LDA screen, X           ; Fetch from frame buffer
                AND 0x3f                ; Mask out don't-matter bits
                TAY
                LDA lut_7seg, Y         ; Convert to 7 segment
                LDY lut_ptr2bit, X      ; Get digit address offset
                STA SCRN_BASE, Y        ; Display digit
                RTS


; Function keyboard_decode
; Decodes keyboard row to key code
; Input: A - keyboard row, X - value to add. Output: A - key code.
; Destroys: A, Y, nmi_temp
keyboard_decode LDY #0
                CLC ; To avoid endless loop, just in case
kb_decode_loop  ROR
                BCC kb_decode_end
                INY
                BCS kb_decode_loop
kb_decode_end   TXA
                STA nmi_temp
                TYA
                CLC
                ADC nmi_temp
                RTS


; Function scan_keyboard
; Scans whole keyboard, stores key code in keycode var
; Input: None. Output: None.
; Destroys: A, X
scan_keyboard   LDA KEYB_BASE + 0x3E
                CMP 0xff
                BNE keyboard_row1
                LDX #KEY_F1
                JSR keyboard_decode
                JMP keyboard_end

keyboard_row1   LDA KEYB_BASE + 0x3D
                CMP 0xff
                BNE keyboard_row2
                LDX #0xc
                JSR keyboard_decode
                JMP keyboard_end

keyboard_row2   LDA KEYB_BASE + 0x3B
                CMP 0xff
                BNE keyboard_row3
                LDX #8
                JSR keyboard_decode
                JMP keyboard_end

keyboard_row3   LDA KEYB_BASE + 0x37
                CMP 0xff
                BNE keyboard_row4
                LDX #4
                JSR keyboard_decode
                JMP keyboard_end

keyboard_row4   LDA KEYB_BASE + 0x2F
                CMP 0xff
                BNE keyboard_row5
                LDX #0
                JSR keyboard_decode
                JMP keyboard_end

keyboard_row5   LDA KEYB_BASE + 0x1F
                CMP 0xff
                BNE keyboard_none
                LDX #KEY_INC
                JSR keyboard_decode
                JMP keyboard_end

keyboard_none   LDA KEY_NONE

keyboard_end    STA keycode
                RTS


; Vectors

* = NMI_VECT
dw nmi

* = IRQ_VECT
dw irq

* = RST_VECT
dw reset
